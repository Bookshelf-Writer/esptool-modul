package code

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"testing"
	"unicode"
)

var pack = "code"
var hText = "/* This file is automatically generated */"
var re = regexp.MustCompile(`[^a-zA-Z0-9]`)

func head() string {
	return "package " + pack + "\n\n" + hText + "\n//######################################//\n\n"
}

var list []byte
var codes map[byte]string

func clean() {
	codes = nil
	codes = make(map[byte]string)
	list = []byte{}
}
func addNew(code byte, text string) {
	codes[code] = text
	list = append(list, code)
}

func toTitleCase(s string) string {
	s = strings.ReplaceAll(s, "-", " ")
	words := strings.Fields(s)

	for i, word := range words {
		if len(word) > 0 {
			word = re.ReplaceAllString(word, "")
			if len(word) > 0 {
				words[i] = string(unicode.ToUpper(rune(word[0]))) + word[1:]
			}

		}
	}

	return strings.Join(words, "")
}

//###########################################################//

func TestOpCode(t *testing.T) {
	name := "Op"
	filepath := "op.go"
	clean()

	addNew(0x02, "Flash Begin")
	addNew(0x03, "Flash Data")
	addNew(0x04, "Flash End")
	addNew(0x05, "Memory Begin")
	addNew(0x06, "Memory End")
	addNew(0x07, "Memory Data")
	addNew(0x08, "Sync")
	addNew(0x09, "Write Register")
	addNew(0x0A, "Read Register")

	addNew(0x0B, "Spi Set Params")
	addNew(0x0D, "Spi Attach Flash")
	addNew(0x0E, "Read Flash")
	addNew(0x0F, "Change Baudrate")
	addNew(0x10, "Flash Deflate Begin")
	addNew(0x11, "Flash Deflate lData")
	addNew(0x12, "Flash Deflate lEnd")
	addNew(0x13, "Spi Flash MD5")

	addNew(0xD0, "Erase Flash")
	addNew(0xD1, "Erase Region")
	addNew(0xD2, "Read Flash Fast")
	addNew(0xD3, "Run User Code")

	//

	file, err := os.OpenFile(filepath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		t.Fatal(err)
		return
	}
	defer file.Close()

	typeName := name + "Type"
	textArr := []string{}
	codeMap := make(map[string]string)

	file.WriteString(head())
	file.WriteString("type " + typeName + " byte\n\n")

	//

	file.WriteString("const (\n")
	for _, code := range list {
		text := codes[code]

		codeConst := name + toTitleCase(text)
		textConst := name + "Text" + toTitleCase(text)
		codeMap[codeConst] = textConst

		textArr = append(textArr, "\t"+textConst+" = \""+text+"\"")
		file.WriteString(fmt.Sprintf("\t%s %s = %d\n", codeConst, typeName, code))
	}
	file.WriteString(")\n\n")

	//

	file.WriteString("const (\n")
	for _, text := range textArr {
		file.WriteString(text + "\n")
	}
	file.WriteString(")\n\n")

	//

	file.WriteString("var " + name + "Map = map[" + typeName + "]string{\n")
	for key, value := range codeMap {
		file.WriteString(fmt.Sprintf("\t%s: %s,\n", key, value))
	}
	file.WriteString("}\n\n")

	file.WriteString("func (obj " + typeName + ") String() string {\n")
	file.WriteString("\tval, ok := " + name + "Map[obj]\n")
	file.WriteString("\tif ok {\n\t\treturn val\n\t}\n")
	file.WriteString("\treturn \"Unknown " + name + "\"\n")
	file.WriteString("}")
}

func TestErrorCode(t *testing.T) {
	name := "Err"
	filepath := "error.go"
	clean()

	addNew(0x05, "Received message is invalid")
	addNew(0x06, "Failed to act on received message")
	addNew(0x07, "Invalid CRC in message")
	addNew(0x08, "Flash write error")
	addNew(0x09, "Flash read error")
	addNew(0x0A, "Flash read length error")
	addNew(0x0B, "Deflate error")

	//

	file, err := os.OpenFile(filepath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		t.Fatal(err)
		return
	}
	defer file.Close()

	typeName := name + "Type"
	textArr := []string{}
	codeMap := make(map[string]string)

	file.WriteString(head())
	file.WriteString("type " + typeName + " byte\n\n")

	//

	file.WriteString("const (\n")
	for _, code := range list {
		text := codes[code]

		codeConst := name + toTitleCase(text)
		textConst := name + "Text" + toTitleCase(text)
		codeMap[codeConst] = textConst

		textArr = append(textArr, "\t"+textConst+" = \""+text+"\"")
		file.WriteString(fmt.Sprintf("\t%s %s = %d\n", codeConst, typeName, code))
	}
	file.WriteString(")\n\n")

	//

	file.WriteString("const (\n")
	for _, text := range textArr {
		file.WriteString(text + "\n")
	}
	file.WriteString(")\n\n")

	//

	file.WriteString("var " + name + "Map = map[" + typeName + "]string{\n")
	for key, value := range codeMap {
		file.WriteString(fmt.Sprintf("\t%s: %s,\n", key, value))
	}
	file.WriteString("}\n\n")

	file.WriteString("func (obj " + typeName + ") String() string {\n")
	file.WriteString("\tval, ok := " + name + "Map[obj]\n")
	file.WriteString("\tif ok {\n\t\treturn val\n\t}\n")
	file.WriteString("\treturn \"Unknown " + name + "\"\n")
	file.WriteString("}")
}
