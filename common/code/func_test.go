package code

import (
	"bytes"
	"fmt"
	"os"
	"regexp"
	"strings"
	"unicode"
)

//###########################################################//

const (
	pack  = "code"
	hText = "/* This file is automatically generated */"
	re    = `[^a-zA-Z0-9]`
)

func toTitleCase(s string) string {
	s = strings.ReplaceAll(s, "-", " ")
	r := regexp.MustCompile(re)
	words := strings.Fields(s)

	for i, word := range words {
		if len(word) > 0 {
			word = r.ReplaceAllString(word, "")
			if len(word) > 0 {
				words[i] = string(unicode.ToUpper(rune(word[0]))) + word[1:]
			}

		}
	}

	return strings.Join(words, "")
}

func head() string {
	return "package " + pack + "\n\n" + hText + "\n//######################################//\n\n"
}

////////

type generatorValueObj struct {
	maps    map[byte]string
	delim   map[byte]bool
	list    []byte
	lastKey byte

	name string
}

type generatorObj struct {
	val generatorValueObj

	filename string
	buf      bytes.Buffer
}

func generatorInit(name string, file string) *generatorObj {
	obj := generatorObj{}
	obj.val.maps = make(map[byte]string)
	obj.val.delim = make(map[byte]bool)

	obj.val.name = name
	obj.filename = file

	return &obj
}

/////////////

func (gen *generatorObj) Write(data []byte) *generatorObj {
	gen.buf.Write(data)
	return gen
}

func (gen *generatorObj) Len() int {
	return gen.buf.Len()
}

func (gen *generatorObj) SaveFile() error {
	file, err := os.OpenFile(gen.filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	file.WriteString(head())
	file.WriteString("type " + gen.TypeName() + " byte\n\n")

	file.Write(gen.buf.Bytes())
	return nil
}

////

func (gen *generatorObj) LN() *generatorObj {
	gen.Write([]byte("\n"))
	return gen
}

func (gen *generatorObj) Byte(b byte) *generatorObj {
	gen.Write([]byte(fmt.Sprintf("%d", b)))
	return gen
}

func (gen *generatorObj) Print(text string) *generatorObj {
	gen.Write([]byte(text))
	return gen
}

func (gen *generatorObj) PrintString(text string) *generatorObj {
	gen.Write([]byte("\"" + text + "\""))
	return gen
}

func (gen *generatorObj) PrintLN(text string) *generatorObj {
	gen.Print(text).LN()
	return gen
}

func (gen *generatorObj) Del(len int) *generatorObj {
	gen.buf.Truncate(gen.Len() - len)
	return gen
}

func (gen *generatorObj) Repeat(pos int) *generatorObj {
	gen.buf.Write([]byte(strings.Repeat("\t", pos)))
	return gen
}

////

func (gen *generatorObj) TypeName() string {
	return gen.val.name + "Type"
}

func (gen *generatorObj) Type() *generatorObj {
	gen.Write([]byte(gen.TypeName()))
	return gen
}

func (gen *generatorObj) Map() *generatorObj {
	gen.Write([]byte(gen.val.name + "Map"))
	return gen
}

func (gen *generatorObj) ConstCode(code string) *generatorObj {
	gen.Write([]byte(gen.val.name + toTitleCase(code)))
	return gen
}

func (gen *generatorObj) ConstText(code string) *generatorObj {
	gen.Write([]byte(gen.val.name + "Text" + toTitleCase(code)))
	return gen
}

/////////////

func (arr *generatorValueObj) Add(code byte, text string) *generatorValueObj {
	arr.lastKey = code

	arr.list = append(arr.list, code)
	arr.maps[code] = text

	return arr
}

func (arr *generatorValueObj) Delim() {
	arr.delim[arr.lastKey] = true
}
